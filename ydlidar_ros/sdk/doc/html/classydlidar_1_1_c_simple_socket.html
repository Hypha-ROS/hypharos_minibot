<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>YDLIDAR SDK: ydlidar::CSimpleSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ydliar.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YDLIDAR SDK
   &#160;<span id="projectnumber">V1.3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceydlidar.html">ydlidar</a></li><li class="navelem"><a class="el" href="classydlidar_1_1_c_simple_socket.html">CSimpleSocket</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classydlidar_1_1_c_simple_socket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ydlidar::CSimpleSocket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_simple_socket_8h_source.html">SimpleSocket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ydlidar::CSimpleSocket:</div>
<div class="dyncontent">
<div class="center"><img src="classydlidar_1_1_c_simple_socket__inherit__graph.png" border="0" usemap="#ydlidar_1_1_c_simple_socket_inherit__map" alt="Inheritance graph"/></div>
<map name="ydlidar_1_1_c_simple_socket_inherit__map" id="ydlidar_1_1_c_simple_socket_inherit__map">
<area shape="rect" id="node3" href="classydlidar_1_1_c_active_socket.html" title="ydlidar::CActiveSocket" alt="" coords="5,155,161,181"/>
<area shape="rect" id="node4" href="classydlidar_1_1_c_passive_socket.html" title="ydlidar::CPassiveSocket" alt="" coords="185,155,352,181"/>
<area shape="rect" id="node2" href="class_channel_device.html" title="ChannelDevice" alt="" coords="120,5,231,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ydlidar::CSimpleSocket:</div>
<div class="dyncontent">
<div class="center"><img src="classydlidar_1_1_c_simple_socket__coll__graph.png" border="0" usemap="#ydlidar_1_1_c_simple_socket_coll__map" alt="Collaboration graph"/></div>
<map name="ydlidar_1_1_c_simple_socket_coll__map" id="ydlidar_1_1_c_simple_socket_coll__map">
<area shape="rect" id="node2" href="class_channel_device.html" title="ChannelDevice" alt="" coords="5,5,116,32"/>
<area shape="rect" id="node4" href="class_c_stat_timer.html" title="CStatTimer" alt="" coords="219,5,308,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7eae391e0dcbafd740488b9a269c8eee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a7eae391e0dcbafd740488b9a269c8eee">CShutdownMode</a> { <a class="el" href="classydlidar_1_1_c_simple_socket.html#a7eae391e0dcbafd740488b9a269c8eeeaeb0f1c6410f5b9f5b03274e9d90592fd">Receives</a> = SHUT_RD, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a7eae391e0dcbafd740488b9a269c8eeea5f942b5d08c08cba6da878fd6438a07b">Sends</a> = SHUT_WR, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a7eae391e0dcbafd740488b9a269c8eeeadc8fe9b07e02af335349800cb62390f2">Both</a> = SHUT_RDWR
 }<tr class="memdesc:a7eae391e0dcbafd740488b9a269c8eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the three possible states for shuting down a socket.  <a href="classydlidar_1_1_c_simple_socket.html#a7eae391e0dcbafd740488b9a269c8eee">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7eae391e0dcbafd740488b9a269c8eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac1428be55f3b5128d122b90c63ef0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0b">CSocketType</a> { <br />
&#160;&#160;<a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0bafcae5434c7863157bdfd65328b5df060">SocketTypeInvalid</a> = 0, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0babc8a6304e4ecb9b329b2cb94cd0b26cd">SocketTypeTcp</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0ba75043b038b2675b576e45beaabee7208">SocketTypeUdp</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0baf827f1847e812176cac6be3b05990ee3">SocketTypeTcp6</a>, 
<br />
&#160;&#160;<a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0babfda0409497645b040b4daf8f9d6bfac">SocketTypeUdp6</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0baa4b38ca3c891ff4c3f7e89d691f90a24">SocketTypeRaw</a>
<br />
 }<tr class="memdesc:a8ac1428be55f3b5128d122b90c63ef0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the socket types defined by <a class="el" href="classydlidar_1_1_c_simple_socket.html">CSimpleSocket</a> class.  <a href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8ac1428be55f3b5128d122b90c63ef0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30314453fd304767763767da7cb5c482"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482">CSocketError</a> { <br />
&#160;&#160;<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a44eae3572de12463261d8db6afc61093">SocketError</a> = -1, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a8f09072cc1be7857d94f4481a0ed40b2">SocketSuccess</a> = 0, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a30e149bbbadcdd34ceb93084abbf3de6">SocketInvalidSocket</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a5684444ef284a45fad2fe5fb83d57f8c">SocketInvalidAddress</a>, 
<br />
&#160;&#160;<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482ae0baed56e8fff1a431ad0f2405f550ad">SocketInvalidPort</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a17ea51e148357465a7b22a1fd36a0c80">SocketConnectionRefused</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482ac6918e17bc0cae682c3db90dc105f7b2">SocketTimedout</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a7a4657dd7a51527dbe81cdbf744279e3">SocketEwouldblock</a>, 
<br />
&#160;&#160;<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a1ef4d2d55b89f12776c358ec1b0da5f6">SocketNotconnected</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a68a97c79867dce992619e6dee347a037">SocketEinprogress</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a2e600d679e03f1761a379765368b1f36">SocketInterrupted</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482aec8ee7c99abfe40eac82ddd7db519856">SocketConnectionAborted</a>, 
<br />
&#160;&#160;<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482ac71c28b4f21becf7e75da8e7c08f734c">SocketProtocolError</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a21794c9689ccf683d069c11f2d8317cf">SocketFirewallError</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482ad960e4fd8ecee3c5fa5a8142263c0699">SocketInvalidSocketBuffer</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a79e6463b44f6e30a482d2571360e63a4">SocketConnectionReset</a>, 
<br />
&#160;&#160;<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a38211a5d3a9d33793a0b26eae5e0aea7">SocketAddressInUse</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482ad20b7ca3362a242d07be421b27788ebe">SocketInvalidPointer</a>, 
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a43c5eccc15f81ce9cf4ca91dd306e71a">SocketEunknown</a>
<br />
 }<tr class="memdesc:a30314453fd304767763767da7cb5c482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines all error codes handled by the <a class="el" href="classydlidar_1_1_c_simple_socket.html">CSimpleSocket</a> class.  <a href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a30314453fd304767763767da7cb5c482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6fef936fe07f2dcabafa405a1a64fbdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fef936fe07f2dcabafa405a1a64fbdf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CSimpleSocket</b> (<a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0b">CSocketType</a> type=<a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0babc8a6304e4ecb9b329b2cb94cd0b26cd">SocketTypeTcp</a>)</td></tr>
<tr class="separator:a6fef936fe07f2dcabafa405a1a64fbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7f5a6cbc7f17386b1ffb04e55ba670"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d7f5a6cbc7f17386b1ffb04e55ba670"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CSimpleSocket</b> (<a class="el" href="classydlidar_1_1_c_simple_socket.html">CSimpleSocket</a> &amp;socket)</td></tr>
<tr class="separator:a0d7f5a6cbc7f17386b1ffb04e55ba670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50622a90672c5c697f2ec7a3a7eec06"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#ae50622a90672c5c697f2ec7a3a7eec06">Initialize</a> (void)</td></tr>
<tr class="separator:ae50622a90672c5c697f2ec7a3a7eec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb30cef80ae0faec59403184cab3bb1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#afbb30cef80ae0faec59403184cab3bb1">Close</a> (void)</td></tr>
<tr class="separator:afbb30cef80ae0faec59403184cab3bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7672c71bc8d8431d36974b946103d7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a5b7672c71bc8d8431d36974b946103d7">Shutdown</a> (<a class="el" href="classydlidar_1_1_c_simple_socket.html#a7eae391e0dcbafd740488b9a269c8eee">CShutdownMode</a> nShutdown)</td></tr>
<tr class="separator:a5b7672c71bc8d8431d36974b946103d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78880461b93d32c9dd5ebaaa21410996"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a78880461b93d32c9dd5ebaaa21410996">Select</a> (void)</td></tr>
<tr class="separator:a78880461b93d32c9dd5ebaaa21410996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00c733a3da13f3cb68c29129db3c369"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#aa00c733a3da13f3cb68c29129db3c369">Select</a> (int32_t nTimeoutSec, int32_t nTimeoutUSec)</td></tr>
<tr class="separator:aa00c733a3da13f3cb68c29129db3c369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf838b0c5b12e15a5d17ff41a1d7f6f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf838b0c5b12e15a5d17ff41a1d7f6f6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>WaitForData</b> (size_t data_count, uint32_t timeout, size_t *returned_size)</td></tr>
<tr class="separator:acf838b0c5b12e15a5d17ff41a1d7f6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901d293660fc2856cbc18885e5ebecfb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a901d293660fc2856cbc18885e5ebecfb">IsSocketValid</a> (void)</td></tr>
<tr class="separator:a901d293660fc2856cbc18885e5ebecfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80785e9658ecd6e118e9876bb222b074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a80785e9658ecd6e118e9876bb222b074">TranslateSocketError</a> (void)</td></tr>
<tr class="separator:a80785e9658ecd6e118e9876bb222b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f3bf2088c4ea789393040155820c02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06f3bf2088c4ea789393040155820c02"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>DescribeError</b> ()</td></tr>
<tr class="separator:a06f3bf2088c4ea789393040155820c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637ff7510be4ea144a3a4d062260a6a9"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a637ff7510be4ea144a3a4d062260a6a9">Receive</a> (int32_t nMaxBytes=1, uint8_t *pBuffer=0)</td></tr>
<tr class="separator:a637ff7510be4ea144a3a4d062260a6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f15f994bfb576630e2c070ec8dd9da"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a96f15f994bfb576630e2c070ec8dd9da">Send</a> (const uint8_t *pBuf, size_t bytesToSend)</td></tr>
<tr class="separator:a96f15f994bfb576630e2c070ec8dd9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3166ce1af0d077060c8d4519c89971"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#aef3166ce1af0d077060c8d4519c89971">Send</a> (const struct iovec *sendVector, int32_t nNumItems)</td></tr>
<tr class="separator:aef3166ce1af0d077060c8d4519c89971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82afc017cc86ae8e69e2ee20d669843"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#ad82afc017cc86ae8e69e2ee20d669843">SendFile</a> (int32_t nOutFd, int32_t nInFd, off_t *pOffset, int32_t nCount)</td></tr>
<tr class="separator:ad82afc017cc86ae8e69e2ee20d669843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dc97d81d75164b88c08c9cfa96298a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a89dc97d81d75164b88c08c9cfa96298a">IsNonblocking</a> (void)</td></tr>
<tr class="separator:a89dc97d81d75164b88c08c9cfa96298a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c89ece94e5c0cd58f246307de8a440"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a51c89ece94e5c0cd58f246307de8a440">SetBlocking</a> (void)</td></tr>
<tr class="separator:a51c89ece94e5c0cd58f246307de8a440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b8048b915d6429415d2014f7b3329d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a17b8048b915d6429415d2014f7b3329d">SetNonblocking</a> (void)</td></tr>
<tr class="separator:a17b8048b915d6429415d2014f7b3329d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3011ed1a5f60ecadd3fe3bbcd80bb9c"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#ae3011ed1a5f60ecadd3fe3bbcd80bb9c">GetData</a> (void)</td></tr>
<tr class="separator:ae3011ed1a5f60ecadd3fe3bbcd80bb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37c4ce4d3e48afd2f7c93f00d39a05"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a6b37c4ce4d3e48afd2f7c93f00d39a05">GetBytesReceived</a> (void)</td></tr>
<tr class="separator:a6b37c4ce4d3e48afd2f7c93f00d39a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799f9d31c9df14706e1c3820db16da64"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a799f9d31c9df14706e1c3820db16da64">GetBytesSent</a> (void)</td></tr>
<tr class="separator:a799f9d31c9df14706e1c3820db16da64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cac43bde00d9d551df09adf18055f94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a5cac43bde00d9d551df09adf18055f94">SetOptionLinger</a> (bool bEnable, uint16_t nTime)</td></tr>
<tr class="separator:a5cac43bde00d9d551df09adf18055f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dc7bedc18197071bf6e1f5f38f606b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a70dc7bedc18197071bf6e1f5f38f606b">SetOptionReuseAddr</a> ()</td></tr>
<tr class="separator:a70dc7bedc18197071bf6e1f5f38f606b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f181044a6690b5c90c1a1223d77e013"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a6f181044a6690b5c90c1a1223d77e013">GetConnectTimeoutSec</a> (void)</td></tr>
<tr class="separator:a6f181044a6690b5c90c1a1223d77e013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78257e60b158e889953b3002842b2225"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a78257e60b158e889953b3002842b2225">GetConnectTimeoutUSec</a> (void)</td></tr>
<tr class="separator:a78257e60b158e889953b3002842b2225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1192d975d7be1ad2561b186841a30fe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a1192d975d7be1ad2561b186841a30fe1">SetConnectTimeout</a> (int32_t nConnectTimeoutSec, int32_t nConnectTimeoutUsec=0)</td></tr>
<tr class="separator:a1192d975d7be1ad2561b186841a30fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3931df9cb5a1e8e9f113f40918e23fe6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a3931df9cb5a1e8e9f113f40918e23fe6">GetReceiveTimeoutSec</a> (void)</td></tr>
<tr class="separator:a3931df9cb5a1e8e9f113f40918e23fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0601177c57fbb8080bcef0ca20d3f2af"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a0601177c57fbb8080bcef0ca20d3f2af">GetReceiveTimeoutUSec</a> (void)</td></tr>
<tr class="separator:a0601177c57fbb8080bcef0ca20d3f2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f4d0ff2f546f6b082ddfb4e7107ba8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a95f4d0ff2f546f6b082ddfb4e7107ba8">SetReceiveTimeout</a> (int32_t nRecvTimeoutSec, int32_t nRecvTimeoutUsec=0)</td></tr>
<tr class="separator:a95f4d0ff2f546f6b082ddfb4e7107ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b41d3ea37453824e78b82573cc95784"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a1b41d3ea37453824e78b82573cc95784">SetMulticast</a> (bool bEnable, uint8_t multicastTTL=1)</td></tr>
<tr class="separator:a1b41d3ea37453824e78b82573cc95784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220ea5b192f922d27c0598db9032687c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a220ea5b192f922d27c0598db9032687c">GetMulticast</a> ()</td></tr>
<tr class="separator:a220ea5b192f922d27c0598db9032687c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23681b9ebd4727e003235da8d0b8bf8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#aa23681b9ebd4727e003235da8d0b8bf8">BindInterface</a> (const char *pInterface)</td></tr>
<tr class="separator:aa23681b9ebd4727e003235da8d0b8bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1240da9f56fa394555f1e89f53a437"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#aaa1240da9f56fa394555f1e89f53a437">GetSendTimeoutSec</a> (void)</td></tr>
<tr class="separator:aaa1240da9f56fa394555f1e89f53a437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76a68329b5c244816c0710912d4d976"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#af76a68329b5c244816c0710912d4d976">GetSendTimeoutUSec</a> (void)</td></tr>
<tr class="separator:af76a68329b5c244816c0710912d4d976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971aadd919b44db33240d9e66d002f22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a971aadd919b44db33240d9e66d002f22">SetSendTimeout</a> (int32_t nSendTimeoutSec, int32_t nSendTimeoutUsec=0)</td></tr>
<tr class="separator:a971aadd919b44db33240d9e66d002f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7b2966c945ef4bf2f7db43cf0b6a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482">CSocketError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#aad7b2966c945ef4bf2f7db43cf0b6a0a">GetSocketError</a> (void)</td></tr>
<tr class="separator:aad7b2966c945ef4bf2f7db43cf0b6a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ec98a6f67603f972084b5a6ba02b16"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a10ec98a6f67603f972084b5a6ba02b16">GetTotalTimeMs</a> ()</td></tr>
<tr class="separator:a10ec98a6f67603f972084b5a6ba02b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba125f0248c625f1eb339dab9053b7dc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#aba125f0248c625f1eb339dab9053b7dc">GetTotalTimeUsec</a> ()</td></tr>
<tr class="separator:aba125f0248c625f1eb339dab9053b7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0348de038f680b7b5801b8138a51e843"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a0348de038f680b7b5801b8138a51e843">GetSocketDscp</a> (void)</td></tr>
<tr class="separator:a0348de038f680b7b5801b8138a51e843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c373c3f300e588ea048773cb1457447"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a8c373c3f300e588ea048773cb1457447">SetSocketDscp</a> (int nDscp)</td></tr>
<tr class="separator:a8c373c3f300e588ea048773cb1457447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6a7a5e3dcb742c07114d8a2dbf547f"><td class="memItemLeft" align="right" valign="top">SOCKET&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a9d6a7a5e3dcb742c07114d8a2dbf547f">GetSocketDescriptor</a> ()</td></tr>
<tr class="separator:a9d6a7a5e3dcb742c07114d8a2dbf547f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0d712e549884b71a2784a1e3ed6396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0b">CSocketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a9a0d712e549884b71a2784a1e3ed6396">GetSocketType</a> ()</td></tr>
<tr class="separator:a9a0d712e549884b71a2784a1e3ed6396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014e2ed02e7df2f68cd3376de2f5fb3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a014e2ed02e7df2f68cd3376de2f5fb3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a014e2ed02e7df2f68cd3376de2f5fb3a">SetSocketType</a> (const <a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0b">CSocketType</a> &amp;type)</td></tr>
<tr class="memdesc:a014e2ed02e7df2f68cd3376de2f5fb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set socket descriptor <br /></td></tr>
<tr class="separator:a014e2ed02e7df2f68cd3376de2f5fb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fe45d2420148f74ec788bf25848513"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#af4fe45d2420148f74ec788bf25848513">GetClientAddr</a> ()</td></tr>
<tr class="separator:af4fe45d2420148f74ec788bf25848513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1688bd7b09b08439dc6ed04e0ac3a2ee"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a1688bd7b09b08439dc6ed04e0ac3a2ee">GetClientPort</a> ()</td></tr>
<tr class="separator:a1688bd7b09b08439dc6ed04e0ac3a2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82110576384fa8d09439621eeff8facc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a82110576384fa8d09439621eeff8facc">GetServerAddr</a> ()</td></tr>
<tr class="separator:a82110576384fa8d09439621eeff8facc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade340bc665e64678c122f51d0799db9a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#ade340bc665e64678c122f51d0799db9a">GetServerPort</a> ()</td></tr>
<tr class="separator:ade340bc665e64678c122f51d0799db9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9003a5b1b8514126f2716a631093ede7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a9003a5b1b8514126f2716a631093ede7">GetReceiveWindowSize</a> ()</td></tr>
<tr class="separator:a9003a5b1b8514126f2716a631093ede7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748ad24b067f4675b778e580a7780279"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a748ad24b067f4675b778e580a7780279">GetSendWindowSize</a> ()</td></tr>
<tr class="separator:a748ad24b067f4675b778e580a7780279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351356b98a5c4cfa87ec0805e88dfcb8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a351356b98a5c4cfa87ec0805e88dfcb8">SetReceiveWindowSize</a> (uint32_t nWindowSize)</td></tr>
<tr class="separator:a351356b98a5c4cfa87ec0805e88dfcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6cb8b7c2f0ac279a31ccc003828d34"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#aec6cb8b7c2f0ac279a31ccc003828d34">SetSendWindowSize</a> (uint32_t nWindowSize)</td></tr>
<tr class="separator:aec6cb8b7c2f0ac279a31ccc003828d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91843dc1e8c8026316bcc9e4617c014e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a91843dc1e8c8026316bcc9e4617c014e">DisableNagleAlgoritm</a> ()</td></tr>
<tr class="separator:a91843dc1e8c8026316bcc9e4617c014e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70aa0a4930465ef1fe4404ba9cc25a8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a70aa0a4930465ef1fe4404ba9cc25a8f">EnableNagleAlgoritm</a> ()</td></tr>
<tr class="separator:a70aa0a4930465ef1fe4404ba9cc25a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc05c47ff75ae8e8ddfbe9194f79de0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc05c47ff75ae8e8ddfbe9194f79de0b"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>Open</b> (const char *pAddr, uint16_t nPort)</td></tr>
<tr class="separator:abc05c47ff75ae8e8ddfbe9194f79de0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783d59226cd991022f63010416e1c932"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a783d59226cd991022f63010416e1c932"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>bindport</b> (const char *, uint32_t)</td></tr>
<tr class="separator:a783d59226cd991022f63010416e1c932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfd098b885030c942fa1e579076802e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbfd098b885030c942fa1e579076802e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>open</b> ()</td></tr>
<tr class="separator:acbfd098b885030c942fa1e579076802e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c921966fb900e2278b314f5c87c574"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50c921966fb900e2278b314f5c87c574"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isOpen</b> ()</td></tr>
<tr class="separator:a50c921966fb900e2278b314f5c87c574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf53a893dacb5774d1754749d94cee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdf53a893dacb5774d1754749d94cee5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>closePort</b> ()</td></tr>
<tr class="separator:abdf53a893dacb5774d1754749d94cee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39efe3c891ed2248248660a0662bd3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad39efe3c891ed2248248660a0662bd3f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>flush</b> ()</td></tr>
<tr class="separator:ad39efe3c891ed2248248660a0662bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167ee5fe381fedf66d66471bd76a42dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a167ee5fe381fedf66d66471bd76a42dd"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>waitfordata</b> (size_t data_count, uint32_t timeout=-1, size_t *returned_size=NULL)</td></tr>
<tr class="separator:a167ee5fe381fedf66d66471bd76a42dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb00605a028a6012311d52de1c0ae3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb00605a028a6012311d52de1c0ae3e"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>writeData</b> (const uint8_t *data, size_t size)</td></tr>
<tr class="separator:a8fb00605a028a6012311d52de1c0ae3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f06f044aac11472224af58bf5c7539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0f06f044aac11472224af58bf5c7539"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>readData</b> (uint8_t *data, size_t size)</td></tr>
<tr class="separator:ae0f06f044aac11472224af58bf5c7539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_channel_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_channel_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_channel_device.html">ChannelDevice</a></td></tr>
<tr class="memitem:af671fd9beeee84ef3be63e617ff46ce4 inherit pub_methods_class_channel_device"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af671fd9beeee84ef3be63e617ff46ce4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>setDTR</b> (bool level=true)</td></tr>
<tr class="separator:af671fd9beeee84ef3be63e617ff46ce4 inherit pub_methods_class_channel_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f9aabcd4f5ae22246d237e1ee69769 inherit pub_methods_class_channel_device"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24f9aabcd4f5ae22246d237e1ee69769"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getByteTime</b> ()</td></tr>
<tr class="separator:a24f9aabcd4f5ae22246d237e1ee69769 inherit pub_methods_class_channel_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40657172e3eb341a31690c684c9ea851 inherit pub_methods_class_channel_device"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40657172e3eb341a31690c684c9ea851"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>ReleasePort</b> ()</td></tr>
<tr class="separator:a40657172e3eb341a31690c684c9ea851 inherit pub_methods_class_channel_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0ee13f2a8edcbf5aab5ad512cc35ad67"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a0ee13f2a8edcbf5aab5ad512cc35ad67">DescribeError</a> (<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482">CSocketError</a> err)</td></tr>
<tr class="separator:a0ee13f2a8edcbf5aab5ad512cc35ad67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a09e8344057c248952650cb408c791520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a09e8344057c248952650cb408c791520">SetSocketError</a> (<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482">CSimpleSocket::CSocketError</a> error)</td></tr>
<tr class="separator:a09e8344057c248952650cb408c791520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77bc8daa8eaca86d52ba2217d0fbb21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#aa77bc8daa8eaca86d52ba2217d0fbb21">SetSocketHandle</a> (SOCKET socket)</td></tr>
<tr class="separator:aa77bc8daa8eaca86d52ba2217d0fbb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51c4b3a445b2c1d997328d7f1234db4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#ae51c4b3a445b2c1d997328d7f1234db4">Flush</a> ()</td></tr>
<tr class="separator:ae51c4b3a445b2c1d997328d7f1234db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a975063df8a398cca0c6a7707d35ec50f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a975063df8a398cca0c6a7707d35ec50f"></a>
SOCKET&#160;</td><td class="memItemRight" valign="bottom"><b>m_socket</b></td></tr>
<tr class="separator:a975063df8a398cca0c6a7707d35ec50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72cb5915498b11a9cf1d43a3757499a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa72cb5915498b11a9cf1d43a3757499a"></a>
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482">CSocketError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#aa72cb5915498b11a9cf1d43a3757499a">m_socketErrno</a></td></tr>
<tr class="memdesc:aa72cb5915498b11a9cf1d43a3757499a"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket handle <br /></td></tr>
<tr class="separator:aa72cb5915498b11a9cf1d43a3757499a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5633e7100666e890451ca3d93211e369"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5633e7100666e890451ca3d93211e369"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a5633e7100666e890451ca3d93211e369">m_pBuffer</a></td></tr>
<tr class="memdesc:a5633e7100666e890451ca3d93211e369"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of last error <br /></td></tr>
<tr class="separator:a5633e7100666e890451ca3d93211e369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5c3bc1ba9941ffc43f3e5adbfa89a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b5c3bc1ba9941ffc43f3e5adbfa89a7"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a7b5c3bc1ba9941ffc43f3e5adbfa89a7">m_nBufferSize</a></td></tr>
<tr class="memdesc:a7b5c3bc1ba9941ffc43f3e5adbfa89a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal send/receive buffer <br /></td></tr>
<tr class="separator:a7b5c3bc1ba9941ffc43f3e5adbfa89a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f837fb21ff5b902578aec851d878d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96f837fb21ff5b902578aec851d878d7"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a96f837fb21ff5b902578aec851d878d7">m_nSocketDomain</a></td></tr>
<tr class="memdesc:a96f837fb21ff5b902578aec851d878d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of internal send/receive buffer <br /></td></tr>
<tr class="separator:a96f837fb21ff5b902578aec851d878d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247125bf95be28d02f7f971d490c444f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a247125bf95be28d02f7f971d490c444f"></a>
<a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0b">CSocketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a247125bf95be28d02f7f971d490c444f">m_nSocketType</a></td></tr>
<tr class="memdesc:a247125bf95be28d02f7f971d490c444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket type PF_INET, PF_INET6 <br /></td></tr>
<tr class="separator:a247125bf95be28d02f7f971d490c444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea11ae9ab50c35a50adcac1e793f3b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ea11ae9ab50c35a50adcac1e793f3b0"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a3ea11ae9ab50c35a50adcac1e793f3b0">m_nBytesReceived</a></td></tr>
<tr class="memdesc:a3ea11ae9ab50c35a50adcac1e793f3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket type - UDP, TCP or RAW <br /></td></tr>
<tr class="separator:a3ea11ae9ab50c35a50adcac1e793f3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258dbbc96bc663d9ca0c15bfb54d1406"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a258dbbc96bc663d9ca0c15bfb54d1406"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a258dbbc96bc663d9ca0c15bfb54d1406">m_nBytesSent</a></td></tr>
<tr class="memdesc:a258dbbc96bc663d9ca0c15bfb54d1406"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of bytes received <br /></td></tr>
<tr class="separator:a258dbbc96bc663d9ca0c15bfb54d1406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d32e0547dc9c03308b7af0948a66fef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d32e0547dc9c03308b7af0948a66fef"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a2d32e0547dc9c03308b7af0948a66fef">m_nFlags</a></td></tr>
<tr class="memdesc:a2d32e0547dc9c03308b7af0948a66fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of bytes sent <br /></td></tr>
<tr class="separator:a2d32e0547dc9c03308b7af0948a66fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b20253d942326ef40f1fa999fa532c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60b20253d942326ef40f1fa999fa532c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a60b20253d942326ef40f1fa999fa532c">m_bIsBlocking</a></td></tr>
<tr class="memdesc:a60b20253d942326ef40f1fa999fa532c"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket flags <br /></td></tr>
<tr class="separator:a60b20253d942326ef40f1fa999fa532c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78977157db65f4475d52f1c5086f54b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab78977157db65f4475d52f1c5086f54b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#ab78977157db65f4475d52f1c5086f54b">m_bIsMulticast</a></td></tr>
<tr class="memdesc:ab78977157db65f4475d52f1c5086f54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">is socket blocking <br /></td></tr>
<tr class="separator:ab78977157db65f4475d52f1c5086f54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9802400ece5d39367bc97f8e17f36ee3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9802400ece5d39367bc97f8e17f36ee3"></a>
struct timeval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a9802400ece5d39367bc97f8e17f36ee3">m_stConnectTimeout</a></td></tr>
<tr class="memdesc:a9802400ece5d39367bc97f8e17f36ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">is the UDP socket multicast; <br /></td></tr>
<tr class="separator:a9802400ece5d39367bc97f8e17f36ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564833529baaa1d51af1429d3dcf8688"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a564833529baaa1d51af1429d3dcf8688"></a>
struct timeval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a564833529baaa1d51af1429d3dcf8688">m_stRecvTimeout</a></td></tr>
<tr class="memdesc:a564833529baaa1d51af1429d3dcf8688"><td class="mdescLeft">&#160;</td><td class="mdescRight">connection timeout <br /></td></tr>
<tr class="separator:a564833529baaa1d51af1429d3dcf8688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73629951a9557f9f1c574191f1e1003c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73629951a9557f9f1c574191f1e1003c"></a>
struct timeval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a73629951a9557f9f1c574191f1e1003c">m_stSendTimeout</a></td></tr>
<tr class="memdesc:a73629951a9557f9f1c574191f1e1003c"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive timeout <br /></td></tr>
<tr class="separator:a73629951a9557f9f1c574191f1e1003c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c5a0ceb502df3b9e54982424c1d2ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89c5a0ceb502df3b9e54982424c1d2ef"></a>
struct sockaddr_in&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a89c5a0ceb502df3b9e54982424c1d2ef">m_stServerSockaddr</a></td></tr>
<tr class="memdesc:a89c5a0ceb502df3b9e54982424c1d2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">send timeout <br /></td></tr>
<tr class="separator:a89c5a0ceb502df3b9e54982424c1d2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f912fad7557934ee8a696acd1808085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f912fad7557934ee8a696acd1808085"></a>
struct sockaddr_in&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a0f912fad7557934ee8a696acd1808085">m_stClientSockaddr</a></td></tr>
<tr class="memdesc:a0f912fad7557934ee8a696acd1808085"><td class="mdescLeft">&#160;</td><td class="mdescRight">server address <br /></td></tr>
<tr class="separator:a0f912fad7557934ee8a696acd1808085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798250958649e5cc5871cecb0a9bde39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a798250958649e5cc5871cecb0a9bde39"></a>
struct sockaddr_in&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a798250958649e5cc5871cecb0a9bde39">m_stMulticastGroup</a></td></tr>
<tr class="memdesc:a798250958649e5cc5871cecb0a9bde39"><td class="mdescLeft">&#160;</td><td class="mdescRight">client address <br /></td></tr>
<tr class="separator:a798250958649e5cc5871cecb0a9bde39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5725db3e331a9c209ee28588e732d96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5725db3e331a9c209ee28588e732d96"></a>
struct linger&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#ad5725db3e331a9c209ee28588e732d96">m_stLinger</a></td></tr>
<tr class="memdesc:ad5725db3e331a9c209ee28588e732d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">multicast group to bind to <br /></td></tr>
<tr class="separator:ad5725db3e331a9c209ee28588e732d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bf1b384ce7429d22bf9da6b9c0e51a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0bf1b384ce7429d22bf9da6b9c0e51a"></a>
<a class="el" href="class_c_stat_timer.html">CStatTimer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#af0bf1b384ce7429d22bf9da6b9c0e51a">m_timer</a></td></tr>
<tr class="memdesc:af0bf1b384ce7429d22bf9da6b9c0e51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">linger flag <br /></td></tr>
<tr class="separator:af0bf1b384ce7429d22bf9da6b9c0e51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddc43e6d8f08a169d9950b7755ae6e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ddc43e6d8f08a169d9950b7755ae6e2"></a>
fd_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a5ddc43e6d8f08a169d9950b7755ae6e2">m_writeFds</a></td></tr>
<tr class="memdesc:a5ddc43e6d8f08a169d9950b7755ae6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics. <br /></td></tr>
<tr class="separator:a5ddc43e6d8f08a169d9950b7755ae6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ec634e790ac3c281966523d30623a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07ec634e790ac3c281966523d30623a5"></a>
fd_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a07ec634e790ac3c281966523d30623a5">m_readFds</a></td></tr>
<tr class="memdesc:a07ec634e790ac3c281966523d30623a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write file descriptor set <br /></td></tr>
<tr class="separator:a07ec634e790ac3c281966523d30623a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95270a1d3db9e0f14fb68c3d39b1b658"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95270a1d3db9e0f14fb68c3d39b1b658"></a>
fd_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a95270a1d3db9e0f14fb68c3d39b1b658">m_errorFds</a></td></tr>
<tr class="memdesc:a95270a1d3db9e0f14fb68c3d39b1b658"><td class="mdescLeft">&#160;</td><td class="mdescRight">read file descriptor set <br /></td></tr>
<tr class="separator:a95270a1d3db9e0f14fb68c3d39b1b658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefd54fe713934a5b4ba634f044c3fba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acefd54fe713934a5b4ba634f044c3fba"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classydlidar_1_1_c_simple_socket.html#acefd54fe713934a5b4ba634f044c3fba">m_addr</a></td></tr>
<tr class="memdesc:acefd54fe713934a5b4ba634f044c3fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">error file descriptor set <br /></td></tr>
<tr class="separator:acefd54fe713934a5b4ba634f044c3fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b74133af4f98bd0f1c853add913bff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9b74133af4f98bd0f1c853add913bff"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_port</b></td></tr>
<tr class="separator:ab9b74133af4f98bd0f1c853add913bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f7f1a64ad147d0fa526e541e653672"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80f7f1a64ad147d0fa526e541e653672"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_open</b></td></tr>
<tr class="separator:a80f7f1a64ad147d0fa526e541e653672"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides a platform independent class to for socket development. This class is designed to abstract socket communication development in a platform independent manner.</p><ul>
<li>Socket types<ol type="1">
<li><a class="el" href="classydlidar_1_1_c_active_socket.html">CActiveSocket</a> Class</li>
<li><a class="el" href="classydlidar_1_1_c_passive_socket.html">CPassiveSocket</a> Class </li>
</ol>
</li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a7eae391e0dcbafd740488b9a269c8eee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classydlidar_1_1_c_simple_socket.html#a7eae391e0dcbafd740488b9a269c8eee">ydlidar::CSimpleSocket::CShutdownMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the three possible states for shuting down a socket. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7eae391e0dcbafd740488b9a269c8eeeaeb0f1c6410f5b9f5b03274e9d90592fd"></a>Receives&#160;</td><td class="fielddoc">
<p>Shutdown passive socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7eae391e0dcbafd740488b9a269c8eeea5f942b5d08c08cba6da878fd6438a07b"></a>Sends&#160;</td><td class="fielddoc">
<p>Shutdown active socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7eae391e0dcbafd740488b9a269c8eeeadc8fe9b07e02af335349800cb62390f2"></a>Both&#160;</td><td class="fielddoc">
<p>Shutdown both active and passive sockets. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a30314453fd304767763767da7cb5c482"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482">ydlidar::CSimpleSocket::CSocketError</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines all error codes handled by the <a class="el" href="classydlidar_1_1_c_simple_socket.html">CSimpleSocket</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a44eae3572de12463261d8db6afc61093"></a>SocketError&#160;</td><td class="fielddoc">
<p>Generic socket error translates to error below. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a8f09072cc1be7857d94f4481a0ed40b2"></a>SocketSuccess&#160;</td><td class="fielddoc">
<p>No socket error. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a30e149bbbadcdd34ceb93084abbf3de6"></a>SocketInvalidSocket&#160;</td><td class="fielddoc">
<p>Invalid socket handle. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a5684444ef284a45fad2fe5fb83d57f8c"></a>SocketInvalidAddress&#160;</td><td class="fielddoc">
<p>Invalid destination address specified. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482ae0baed56e8fff1a431ad0f2405f550ad"></a>SocketInvalidPort&#160;</td><td class="fielddoc">
<p>Invalid destination port specified. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a17ea51e148357465a7b22a1fd36a0c80"></a>SocketConnectionRefused&#160;</td><td class="fielddoc">
<p>No server is listening at remote address. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482ac6918e17bc0cae682c3db90dc105f7b2"></a>SocketTimedout&#160;</td><td class="fielddoc">
<p>Timed out while attempting operation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a7a4657dd7a51527dbe81cdbf744279e3"></a>SocketEwouldblock&#160;</td><td class="fielddoc">
<p>Operation would block if socket were blocking. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a1ef4d2d55b89f12776c358ec1b0da5f6"></a>SocketNotconnected&#160;</td><td class="fielddoc">
<p>Currently not connected. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a68a97c79867dce992619e6dee347a037"></a>SocketEinprogress&#160;</td><td class="fielddoc">
<p>Socket is non-blocking and the connection cannot be completed immediately. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a2e600d679e03f1761a379765368b1f36"></a>SocketInterrupted&#160;</td><td class="fielddoc">
<p>Call was interrupted by a signal that was caught before a valid connection arrived. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482aec8ee7c99abfe40eac82ddd7db519856"></a>SocketConnectionAborted&#160;</td><td class="fielddoc">
<p>The connection has been aborted. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482ac71c28b4f21becf7e75da8e7c08f734c"></a>SocketProtocolError&#160;</td><td class="fielddoc">
<p>Invalid protocol for operation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a21794c9689ccf683d069c11f2d8317cf"></a>SocketFirewallError&#160;</td><td class="fielddoc">
<p>Firewall rules forbid connection. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482ad960e4fd8ecee3c5fa5a8142263c0699"></a>SocketInvalidSocketBuffer&#160;</td><td class="fielddoc">
<p>The receive buffer point outside the process's address space. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a79e6463b44f6e30a482d2571360e63a4"></a>SocketConnectionReset&#160;</td><td class="fielddoc">
<p>Connection was forcibly closed by the remote host. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a38211a5d3a9d33793a0b26eae5e0aea7"></a>SocketAddressInUse&#160;</td><td class="fielddoc">
<p>Address already in use. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482ad20b7ca3362a242d07be421b27788ebe"></a>SocketInvalidPointer&#160;</td><td class="fielddoc">
<p>Pointer type supplied as argument is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30314453fd304767763767da7cb5c482a43c5eccc15f81ce9cf4ca91dd306e71a"></a>SocketEunknown&#160;</td><td class="fielddoc">
<p>Unknown error please report to <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'k@'+'car'+'ri'+'erl'+'ab'+'s.c'+'om'; return false;">mark@<span style="display: none;">.nosp@m.</span>carr<span style="display: none;">.nosp@m.</span>ierla<span style="display: none;">.nosp@m.</span>bs.c<span style="display: none;">.nosp@m.</span>om</a>. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8ac1428be55f3b5128d122b90c63ef0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0b">ydlidar::CSimpleSocket::CSocketType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the socket types defined by <a class="el" href="classydlidar_1_1_c_simple_socket.html">CSimpleSocket</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8ac1428be55f3b5128d122b90c63ef0bafcae5434c7863157bdfd65328b5df060"></a>SocketTypeInvalid&#160;</td><td class="fielddoc">
<p>Invalid socket type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ac1428be55f3b5128d122b90c63ef0babc8a6304e4ecb9b329b2cb94cd0b26cd"></a>SocketTypeTcp&#160;</td><td class="fielddoc">
<p>Defines socket as TCP socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ac1428be55f3b5128d122b90c63ef0ba75043b038b2675b576e45beaabee7208"></a>SocketTypeUdp&#160;</td><td class="fielddoc">
<p>Defines socket as UDP socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ac1428be55f3b5128d122b90c63ef0baf827f1847e812176cac6be3b05990ee3"></a>SocketTypeTcp6&#160;</td><td class="fielddoc">
<p>Defines socket as IPv6 TCP socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ac1428be55f3b5128d122b90c63ef0babfda0409497645b040b4daf8f9d6bfac"></a>SocketTypeUdp6&#160;</td><td class="fielddoc">
<p>Defines socket as IPv6 UDP socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ac1428be55f3b5128d122b90c63ef0baa4b38ca3c891ff4c3f7e89d691f90a24"></a>SocketTypeRaw&#160;</td><td class="fielddoc">
<p>Provides raw network protocol access. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa23681b9ebd4727e003235da8d0b8bf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::BindInterface </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pInterface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bind socket to a specific interface when using multicast. </p><dl class="section return"><dt>Returns</dt><dd>true if successfully bound to interface </dd></dl>

</div>
</div>
<a class="anchor" id="afbb30cef80ae0faec59403184cab3bb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::Close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Close socket </p><dl class="section return"><dt>Returns</dt><dd>true if successfully closed otherwise returns false. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ee13f2a8edcbf5aab5ad512cc35ad67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * CSimpleSocket::DescribeError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482">CSocketError</a>&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a human-readable description of the given error code or the last error code of a socket </p>

</div>
</div>
<a class="anchor" id="a91843dc1e8c8026316bcc9e4617c014e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::DisableNagleAlgoritm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable the Nagle algorithm (Set TCP_NODELAY to true) </p><dl class="section return"><dt>Returns</dt><dd>false if failed to set socket option otherwise return true; </dd></dl>

</div>
</div>
<a class="anchor" id="a70aa0a4930465ef1fe4404ba9cc25a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::EnableNagleAlgoritm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable the Nagle algorithm (Set TCP_NODELAY to false) </p><dl class="section return"><dt>Returns</dt><dd>false if failed to set socket option otherwise return true; </dd></dl>

</div>
</div>
<a class="anchor" id="ae51c4b3a445b2c1d997328d7f1234db4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flush the socket descriptor owned by the object. </p><dl class="section return"><dt>Returns</dt><dd>true data was successfully sent, else return false; </dd></dl>

</div>
</div>
<a class="anchor" id="a6b37c4ce4d3e48afd2f7c93f00d39a05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ydlidar::CSimpleSocket::GetBytesReceived </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of bytes received on the last call to CSocket::Receive(). </p><dl class="section return"><dt>Returns</dt><dd>number of bytes received. </dd></dl>

</div>
</div>
<a class="anchor" id="a799f9d31c9df14706e1c3820db16da64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ydlidar::CSimpleSocket::GetBytesSent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of bytes sent on the last call to CSocket::Send(). </p><dl class="section return"><dt>Returns</dt><dd>number of bytes sent. </dd></dl>

</div>
</div>
<a class="anchor" id="af4fe45d2420148f74ec788bf25848513"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* ydlidar::CSimpleSocket::GetClientAddr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns clients Internet host address as a string in standard numbers-and-dots notation. </p><dl class="section return"><dt>Returns</dt><dd>NULL if invalid </dd></dl>

</div>
</div>
<a class="anchor" id="a1688bd7b09b08439dc6ed04e0ac3a2ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ydlidar::CSimpleSocket::GetClientPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the port number on which the client is connected. </p><dl class="section return"><dt>Returns</dt><dd>client port number. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f181044a6690b5c90c1a1223d77e013"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ydlidar::CSimpleSocket::GetConnectTimeoutSec </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the timeout value that specifies the maximum number of seconds a call to CSimpleSocket::Open waits until it completes. </p><dl class="section return"><dt>Returns</dt><dd>the length of time in seconds </dd></dl>

</div>
</div>
<a class="anchor" id="a78257e60b158e889953b3002842b2225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ydlidar::CSimpleSocket::GetConnectTimeoutUSec </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the timeout value that specifies the maximum number of microseconds a call to CSimpleSocket::Open waits until it completes. </p><dl class="section return"><dt>Returns</dt><dd>the length of time in microseconds </dd></dl>

</div>
</div>
<a class="anchor" id="ae3011ed1a5f60ecadd3fe3bbcd80bb9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* ydlidar::CSimpleSocket::GetData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to internal receive buffer. The user MUST not free this pointer when finished. This memory is managed internally by the CSocket class. </p><dl class="section return"><dt>Returns</dt><dd>pointer to data if valid, else returns NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a220ea5b192f922d27c0598db9032687c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ydlidar::CSimpleSocket::GetMulticast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if socket is multicast or false is socket is unicast </p><dl class="section return"><dt>Returns</dt><dd>true if multicast is enabled </dd></dl>

</div>
</div>
<a class="anchor" id="a3931df9cb5a1e8e9f113f40918e23fe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ydlidar::CSimpleSocket::GetReceiveTimeoutSec </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the timeout value that specifies the maximum number of seconds a a call to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a637ff7510be4ea144a3a4d062260a6a9">CSimpleSocket::Receive</a> waits until it completes. </p><dl class="section return"><dt>Returns</dt><dd>the length of time in seconds </dd></dl>

</div>
</div>
<a class="anchor" id="a0601177c57fbb8080bcef0ca20d3f2af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ydlidar::CSimpleSocket::GetReceiveTimeoutUSec </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the timeout value that specifies the maximum number of microseconds a call to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a637ff7510be4ea144a3a4d062260a6a9">CSimpleSocket::Receive</a> waits until it completes. </p><dl class="section return"><dt>Returns</dt><dd>the length of time in microseconds </dd></dl>

</div>
</div>
<a class="anchor" id="a9003a5b1b8514126f2716a631093ede7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ydlidar::CSimpleSocket::GetReceiveWindowSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TCP receive buffer window size for the current socket object. <br />
<br />
<b>NOTE:</b> Linux will set the receive buffer to twice the value passed. </p><dl class="section return"><dt>Returns</dt><dd>zero on failure else the number of bytes of the TCP receive buffer window size if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa1240da9f56fa394555f1e89f53a437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ydlidar::CSimpleSocket::GetSendTimeoutSec </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the timeout value that specifies the maximum number of seconds a a call to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a96f15f994bfb576630e2c070ec8dd9da">CSimpleSocket::Send</a> waits until it completes. </p><dl class="section return"><dt>Returns</dt><dd>the length of time in seconds </dd></dl>

</div>
</div>
<a class="anchor" id="af76a68329b5c244816c0710912d4d976"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ydlidar::CSimpleSocket::GetSendTimeoutUSec </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the timeout value that specifies the maximum number of microseconds a call to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a96f15f994bfb576630e2c070ec8dd9da">CSimpleSocket::Send</a> waits until it completes. </p><dl class="section return"><dt>Returns</dt><dd>the length of time in microseconds </dd></dl>

</div>
</div>
<a class="anchor" id="a748ad24b067f4675b778e580a7780279"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ydlidar::CSimpleSocket::GetSendWindowSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TCP send buffer window size for the current socket object. <br />
<br />
<b>NOTE:</b> Linux will set the send buffer to twice the value passed. </p><dl class="section return"><dt>Returns</dt><dd>zero on failure else the number of bytes of the TCP receive buffer window size if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a82110576384fa8d09439621eeff8facc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* ydlidar::CSimpleSocket::GetServerAddr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns server Internet host address as a string in standard numbers-and-dots notation. </p><dl class="section return"><dt>Returns</dt><dd>NULL if invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ade340bc665e64678c122f51d0799db9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ydlidar::CSimpleSocket::GetServerPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the port number on which the server is connected. </p><dl class="section return"><dt>Returns</dt><dd>server port number. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d6a7a5e3dcb742c07114d8a2dbf547f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SOCKET ydlidar::CSimpleSocket::GetSocketDescriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return socket descriptor </p><dl class="section return"><dt>Returns</dt><dd>socket descriptor which is a signed 32 bit integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a0348de038f680b7b5801b8138a51e843"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSimpleSocket::GetSocketDscp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return Differentiated Services Code Point (DSCP) value currently set on the socket object. </p><dl class="section return"><dt>Returns</dt><dd>DSCP for current socket object. <br />
<br />
 <b>NOTE:</b> Windows special notes <a href="http://support.microsoft.com/kb/248611">http://support.microsoft.com/kb/248611</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aad7b2966c945ef4bf2f7db43cf0b6a0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482">CSocketError</a> ydlidar::CSimpleSocket::GetSocketError </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the last error that occured for the instace of the <a class="el" href="classydlidar_1_1_c_simple_socket.html">CSimpleSocket</a> instance. This method should be called immediately to retrieve the error code for the failing mehtod call. </p><dl class="section return"><dt>Returns</dt><dd>last error that occured. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a0d712e549884b71a2784a1e3ed6396"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0b">CSocketType</a> ydlidar::CSimpleSocket::GetSocketType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return socket descriptor </p><dl class="section return"><dt>Returns</dt><dd>socket descriptor which is a signed 32 bit integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a10ec98a6f67603f972084b5a6ba02b16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ydlidar::CSimpleSocket::GetTotalTimeMs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the total time the of the last operation in milliseconds. </p><dl class="section return"><dt>Returns</dt><dd>number of milliseconds of last operation. </dd></dl>

</div>
</div>
<a class="anchor" id="aba125f0248c625f1eb339dab9053b7dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ydlidar::CSimpleSocket::GetTotalTimeUsec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the total time the of the last operation in microseconds. </p><dl class="section return"><dt>Returns</dt><dd>number of microseconds or last operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ae50622a90672c5c697f2ec7a3a7eec06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::Initialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize instance of CSocket. This method MUST be called before an object can be used. Errors : CSocket::SocketProtocolError, CSocket::SocketInvalidSocket, </p><dl class="section return"><dt>Returns</dt><dd>true if properly initialized. </dd></dl>

</div>
</div>
<a class="anchor" id="a89dc97d81d75164b88c08c9cfa96298a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ydlidar::CSimpleSocket::IsNonblocking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns blocking/non-blocking state of socket. </p><dl class="section return"><dt>Returns</dt><dd>true if the socket is non-blocking, else return false. </dd></dl>

</div>
</div>
<a class="anchor" id="a901d293660fc2856cbc18885e5ebecfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ydlidar::CSimpleSocket::IsSocketValid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does the current instance of the socket object contain a valid socket descriptor. </p><dl class="section return"><dt>Returns</dt><dd>true if the socket object contains a valid socket descriptor. </dd></dl>

</div>
</div>
<a class="anchor" id="a637ff7510be4ea144a3a4d062260a6a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSimpleSocket::Receive </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nMaxBytes</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to receive a block of data on an established connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nMaxBytes</td><td>maximum number of bytes to receive. </td></tr>
    <tr><td class="paramname">pBuffer,memory</td><td>where to receive the data, NULL receives to internal buffer returned with <a class="el" href="classydlidar_1_1_c_simple_socket.html#ae3011ed1a5f60ecadd3fe3bbcd80bb9c">GetData()</a> Non-NULL receives directly there, but <a class="el" href="classydlidar_1_1_c_simple_socket.html#ae3011ed1a5f60ecadd3fe3bbcd80bb9c">GetData()</a> will return WRONG ptr! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes actually received. </dd>
<dd>
of zero means the connection has been shutdown on the other side. </dd>
<dd>
of -1 means that an error has occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a78880461b93d32c9dd5ebaaa21410996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ydlidar::CSimpleSocket::Select </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Examine the socket descriptor sets currently owned by the instance of the socket class (the readfds, writefds, and errorfds parameters) to see whether some of their descriptors are ready for reading, are ready for writing, or have an exceptional condition pending, respectively. Block until an event happens on the specified file descriptors. </p><dl class="section return"><dt>Returns</dt><dd>true if socket has data ready, or false if not ready or timed out. </dd></dl>

</div>
</div>
<a class="anchor" id="aa00c733a3da13f3cb68c29129db3c369"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::Select </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nTimeoutSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nTimeoutUSec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Examine the socket descriptor sets currently owned by the instance of the socket class (the readfds, writefds, and errorfds parameters) to see whether some of their descriptors are ready for reading, are ready for writing, or have an exceptional condition pending, respectively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nTimeoutSec</td><td>timeout in seconds for select. </td></tr>
    <tr><td class="paramname">nTimeoutUSec</td><td>timeout in micro seconds for select. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if socket has data ready, or false if not ready or timed out. </dd></dl>

</div>
</div>
<a class="anchor" id="a96f15f994bfb576630e2c070ec8dd9da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSimpleSocket::Send </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytesToSend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to send a block of data on an established connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>block of data to be sent. </td></tr>
    <tr><td class="paramname">bytesToSend</td><td>size of data block to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes actually sent. </dd>
<dd>
of zero means the connection has been shutdown on the other side. </dd>
<dd>
of -1 means that an error has occurred. </dd></dl>

<p>Reimplemented in <a class="el" href="classydlidar_1_1_c_passive_socket.html#a7e7d6f48e0ed305b506e270e350692ad">ydlidar::CPassiveSocket</a>.</p>

</div>
</div>
<a class="anchor" id="aef3166ce1af0d077060c8d4519c89971"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSimpleSocket::Send </td>
          <td>(</td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>sendVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nNumItems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to send at most nNumItem blocks described by sendVector to the socket descriptor associated with the socket object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendVector</td><td>pointer to an array of iovec structures </td></tr>
    <tr><td class="paramname">nNumItems</td><td>number of items in the vector to process <br />
<b>NOTE:</b> Buffers are processed in the order specified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes actually sent, return of zero means the connection has been shutdown on the other side, and a return of -1 means that an error has occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ad82afc017cc86ae8e69e2ee20d669843"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSimpleSocket::SendFile </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nOutFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nInFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t *&#160;</td>
          <td class="paramname"><em>pOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies data between one file descriptor and another. On some systems this copying is done within the kernel, and thus is more efficient than the combination of <a class="el" href="classydlidar_1_1_c_simple_socket.html#a96f15f994bfb576630e2c070ec8dd9da">CSimpleSocket::Send</a> and <a class="el" href="classydlidar_1_1_c_simple_socket.html#a637ff7510be4ea144a3a4d062260a6a9">CSimpleSocket::Receive</a>, which would require transferring data to and from user space. <br />
<b>Note:</b> This is available on all implementations, but the kernel implementation is only available on Unix type systems. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nOutFd</td><td>descriptor opened for writing. </td></tr>
    <tr><td class="paramname">nInFd</td><td>descriptor opened for reading. </td></tr>
    <tr><td class="paramname">pOffset</td><td>from which to start reading data from input file. </td></tr>
    <tr><td class="paramname">nCount</td><td>number of bytes to copy between file descriptors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to the out socket descriptor. </dd></dl>

</div>
</div>
<a class="anchor" id="a51c89ece94e5c0cd58f246307de8a440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::SetBlocking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the socket to blocking. </p><dl class="section return"><dt>Returns</dt><dd>true if successful set to blocking, else return false; </dd></dl>

</div>
</div>
<a class="anchor" id="a1192d975d7be1ad2561b186841a30fe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ydlidar::CSimpleSocket::SetConnectTimeout </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nConnectTimeoutSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nConnectTimeoutUsec</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the timeout value that specifies the maximum amount of time a call to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a637ff7510be4ea144a3a4d062260a6a9">CSimpleSocket::Receive</a> waits until it completes. Use the method <a class="el" href="classydlidar_1_1_c_simple_socket.html#a95f4d0ff2f546f6b082ddfb4e7107ba8">CSimpleSocket::SetReceiveTimeout</a> to specify the number of seconds to wait. If a call to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a637ff7510be4ea144a3a4d062260a6a9">CSimpleSocket::Receive</a> has blocked for the specified length of time without receiving additional data, it returns with a partial count or <a class="el" href="classydlidar_1_1_c_simple_socket.html#aad7b2966c945ef4bf2f7db43cf0b6a0a">CSimpleSocket::GetSocketError</a> set to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a7a4657dd7a51527dbe81cdbf744279e3" title="Operation would block if socket were blocking. ">CSimpleSocket::SocketEwouldblock</a> if no data were received. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nConnectTimeoutSec</td><td>of timeout in seconds. </td></tr>
    <tr><td class="paramname">nConnectTimeoutUsec</td><td>of timeout in microseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if socket connection timeout was successfully set. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b41d3ea37453824e78b82573cc95784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::SetMulticast </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>multicastTTL</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/disable multicast for a socket. This options is only valid for socket descriptors of type <a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0ba75043b038b2675b576e45beaabee7208" title="Defines socket as UDP socket. ">CSimpleSocket::SocketTypeUdp</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if multicast was enabled or false if socket type is not <a class="el" href="classydlidar_1_1_c_simple_socket.html#a8ac1428be55f3b5128d122b90c63ef0ba75043b038b2675b576e45beaabee7208" title="Defines socket as UDP socket. ">CSimpleSocket::SocketTypeUdp</a> and the error will be set to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482ac71c28b4f21becf7e75da8e7c08f734c" title="Invalid protocol for operation. ">CSimpleSocket::SocketProtocolError</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a17b8048b915d6429415d2014f7b3329d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::SetNonblocking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the socket as non-blocking. </p><dl class="section return"><dt>Returns</dt><dd>true if successful set to non-blocking, else return false; </dd></dl>

</div>
</div>
<a class="anchor" id="a5cac43bde00d9d551df09adf18055f94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::SetOptionLinger </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls the actions taken when <a class="el" href="classydlidar_1_1_c_simple_socket.html#afbb30cef80ae0faec59403184cab3bb1">CSimpleSocket::Close</a> is executed on a socket object that has unsent data. The default value for this option is <b>off</b>.</p><ul>
<li><p class="startli">Following are the three possible scenarios.</p><ol type="1">
<li><b>bEnable</b> is false, <a class="el" href="classydlidar_1_1_c_simple_socket.html#afbb30cef80ae0faec59403184cab3bb1">CSimpleSocket::Close</a> returns immediately, but any unset data is transmitted (after <a class="el" href="classydlidar_1_1_c_simple_socket.html#afbb30cef80ae0faec59403184cab3bb1">CSimpleSocket::Close</a> returns)</li>
<li><b>bEnable</b> is true and <b>nTime</b> is zero, <a class="el" href="classydlidar_1_1_c_simple_socket.html#afbb30cef80ae0faec59403184cab3bb1">CSimpleSocket::Close</a> return immediately and any unsent data is discarded.</li>
<li><b>bEnable</b> is true and <b>nTime</b> is nonzero, <a class="el" href="classydlidar_1_1_c_simple_socket.html#afbb30cef80ae0faec59403184cab3bb1">CSimpleSocket::Close</a> does not return until all unsent data is transmitted (or the connection is Closed by the remote system). <br />
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td>true to enable option false to disable option. </td></tr>
    <tr><td class="paramname">nTime</td><td>time in seconds to linger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if option successfully set </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a70dc7bedc18197071bf6e1f5f38f606b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::SetOptionReuseAddr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells the kernel that even if this port is busy (in the TIME_WAIT state), go ahead and reuse it anyway. If it is busy, but with another state, you will still get an address already in use error. </p><dl class="section return"><dt>Returns</dt><dd>true if option successfully set </dd></dl>

</div>
</div>
<a class="anchor" id="a95f4d0ff2f546f6b082ddfb4e7107ba8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::SetReceiveTimeout </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nRecvTimeoutSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nRecvTimeoutUsec</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the timeout value that specifies the maximum amount of time a call to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a637ff7510be4ea144a3a4d062260a6a9">CSimpleSocket::Receive</a> waits until it completes. Use the method <a class="el" href="classydlidar_1_1_c_simple_socket.html#a95f4d0ff2f546f6b082ddfb4e7107ba8">CSimpleSocket::SetReceiveTimeout</a> to specify the number of seconds to wait. If a call to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a637ff7510be4ea144a3a4d062260a6a9">CSimpleSocket::Receive</a> has blocked for the specified length of time without receiving additional data, it returns with a partial count or <a class="el" href="classydlidar_1_1_c_simple_socket.html#aad7b2966c945ef4bf2f7db43cf0b6a0a">CSimpleSocket::GetSocketError</a> set to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482a7a4657dd7a51527dbe81cdbf744279e3" title="Operation would block if socket were blocking. ">CSimpleSocket::SocketEwouldblock</a> if no data were received. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nRecvTimeoutSec</td><td>of timeout in seconds. </td></tr>
    <tr><td class="paramname">nRecvTimeoutUsec</td><td>of timeout in microseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if socket timeout was successfully set. </dd></dl>

</div>
</div>
<a class="anchor" id="a351356b98a5c4cfa87ec0805e88dfcb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ydlidar::CSimpleSocket::SetReceiveWindowSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nWindowSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TCP receive buffer window size for the current socket object. <br />
<br />
<b>NOTE:</b> Linux will set the receive buffer to twice the value passed. </p><dl class="section return"><dt>Returns</dt><dd>zero on failure else the number of bytes of the TCP send buffer window size if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a971aadd919b44db33240d9e66d002f22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::SetSendTimeout </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nSendTimeoutSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nSendTimeoutUsec</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the timeout value that specifies the maximum amount of time a call to <a class="el" href="classydlidar_1_1_c_simple_socket.html#a96f15f994bfb576630e2c070ec8dd9da">CSimpleSocket::Send</a> waits until it completes. </p><dl class="section return"><dt>Returns</dt><dd>the length of time in seconds </dd></dl>

</div>
</div>
<a class="anchor" id="aec6cb8b7c2f0ac279a31ccc003828d34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ydlidar::CSimpleSocket::SetSendWindowSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nWindowSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TCP send buffer window size for the current socket object. <br />
<br />
<b>NOTE:</b> Linux will set the send buffer to twice the value passed. </p><dl class="section return"><dt>Returns</dt><dd>zero on failure else the number of bytes of the TCP send buffer window size if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c373c3f300e588ea048773cb1457447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::SetSocketDscp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDscp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Differentiated Services Code Point (DSCP) for socket object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nDscp</td><td>value of TOS setting which will be converted to DSCP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if DSCP value was properly set <br />
<br />
 <b>NOTE:</b> Windows special notes <a href="http://support.microsoft.com/kb/248611">http://support.microsoft.com/kb/248611</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a09e8344057c248952650cb408c791520"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ydlidar::CSimpleSocket::SetSocketError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a30314453fd304767763767da7cb5c482">CSimpleSocket::CSocketError</a>&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set internal socket error to that specified error </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>type of error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa77bc8daa8eaca86d52ba2217d0fbb21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ydlidar::CSimpleSocket::SetSocketHandle </td>
          <td>(</td>
          <td class="paramtype">SOCKET&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set object socket handle to that specified as parameter </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>value of socket descriptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b7672c71bc8d8431d36974b946103d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CSimpleSocket::Shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classydlidar_1_1_c_simple_socket.html#a7eae391e0dcbafd740488b9a269c8eee">CShutdownMode</a>&#160;</td>
          <td class="paramname"><em>nShutdown</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shutdown shut down socket send and receive operations CShutdownMode::Receives - Disables further receive operations. CShutdownMode::Sends - Disables further send operations. CShutdownBoth:: - Disables further send and receive operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nShutdown</td><td>specifies the type of shutdown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfully shutdown otherwise returns false. </dd></dl>

</div>
</div>
<a class="anchor" id="a80785e9658ecd6e118e9876bb222b074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSimpleSocket::TranslateSocketError </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides a standard error code for cross platform development by mapping the operating system error to an error defined by the CSocket class. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="_simple_socket_8h_source.html">SimpleSocket.h</a></li>
<li>src/SimpleSocket.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
